---
title: '付録: キャッシュ、PPR'
---

_Next.js のキャッシュは極めて複雑なので細部まで理解する必要はありません。ほとんどの人がボンネットの中身を知らなくても車を運転できているのと同じです。_

的な内容が[公式ドキュメント](https://nextjs.org/docs/app/building-your-application/caching)にあり、細かいことは気にするなと言われています。とはいえ気になるのがエンジニアの性なので噛み砕いて説明します。

まずは以下の図を見てください。

![](/images/cache-chart.png)

すでにごちゃついていますがこれでもだいぶオブラートに包んでいます。この図をもとに要点をまとめます。

# データキャッシュ

まず最も重要なのは**データキャッシュ**です。DB から取得したデータはデータキャッシュに**永続的に**キャッシュされます。キャッシュに有効期限を付与したり強制的に消すこともできますが、デフォルトでは勝手に、永続的にキャッシュされます。

AWS をはじめ昨今のインフラは通信量に対し従量課金されます。たとえば 100 万人がデータをリクエストしたらデータベースに 100 万回の通信が発生し、運用費が嵩んでいきます。

しかしこのデータキャッシュのおかげで、100 万人が同じデータをリクエストしてもデータベース本体へのリクエストは 1 回しか発生しません。これによりインフラコストを大きく節約できるだけでなく、データベース通信によるタイムロスも軽減します。

## データキャッシュを更新するには？

たとえばデータベースで記事の誤字が修正されても、修正前のデータキャッシュが残っている限りそちらが参照されるのでいつまで経っても誤字の修正が反映されません。これを解決するために、データを更新した際は `revalidate` メソッドを使ってデータキャッシュを削除します。削除することで、次にデータリクエストがあった際にデータベース本体を参照してくれます。加えて、最新のデータが新たにデータキャッシュされます。

`revalidate` は主に

- `revalidateTag` と `revalidatePath` を使って任意のタイミングで発動するパターン([Doc](https://nextjs.org/docs/app/building-your-application/caching))
- fetch 時に `revalidate` オプションを使ってキャッシュに有効期限を設定するパターン([Doc](https://nextjs.org/docs/app/building-your-application/caching))

の 2 通りがあります。記事データのようにキャッシュを更新すべきタイミングが明確な場合、前者を使ってデータ更新時にキャッシュを削除するのが一般的です。

## ⚠️ 現在は fetch のみ対応

データキャッシュは現在 fetch を用いたリクエストしかキャッシュしてくれません。たとえば [Prisma](https://www.prisma.io) などの ORM は fetch を使わないのでデータキャッシュの恩恵を受けられません。

[unstable_cache](https://nextjs.org/docs/app/api-reference/functions/unstable_cache) というベータ機能を使うことで ORM でもデータキャッシュ可能になりますが、不安定でバグが多いためまだ使える段階にありません。

Prisma を使いながら安定的にデータフェッチの恩恵を受ける場合、 API ルートを作ってそちらを fetch するという回りくどいアプローチが必要です。RSC や Server Actions を使えば API が不要であるため、最終的には unstable_cache の安定版を使って不要な API を排除することが望ましいです。

# リクエストのメモ

リクエストのメモは**レンダリング過程で発生したリクエストの結果をレンダリング中のみ一時的にメモリにキャッシュ（メモ化）する機能**です。したがってレンダリング後は破棄されます。

こちらも fetch のみ有効ですが、 React の `cache` で関数を囲めば ORM を使用するリクエストもキャッシュできます。（リクエストをキャッシュするというより、関数の返却値をキャッシュするイメージ）

ただ、画面のレンダリング中にまったく同じリクエストが何度も発生するシーンがあまりないことに加え、仮に重複するリクエストが発生してもその対象はデータキャッシュになるため、大元のデータベースに対し無駄なリクエストが到達することはありません。

たとえばユーザー A のプロフィール画面をレンダリングする過程で、ユーザー A のデータを 5 回取得するような実装があったとします。通常ならデータキャッシュに対し 5 回のリクエストが発生しますが、リクエスト結果がメモ化されることでデータキャッシュに対し 1 度のリクエストで済みます。この場合の恩恵はリクエストのタイムラグがなくなるのでレンダリング速度が上がることです。

もう一つの恩恵は実装が直観的になることです。これまではクライアントでフェッチ結果を一元管理してコンポーネント間でシェアする実装が必要でした。リクエストのメモ化によりそれが不要になりました。フェッチ結果がメモ化されることにより、データを必要とするコンポーネントが各々同じフェッチを行ってもフェッチが重複しないためです。

# フルルートキャッシュ

フルルートキャッシュは**レンダリング結果を丸ごと、永続的に**キャッシュする仕組みです。基本的にはビルド時にフルルートキャッシュが作られます。

たとえばランディングページがビルド時にレンダリングされてフルルートキャッシュされていた場合、ユーザーがランディングページにアクセスするとフルルートキャッシュの結果が返されます。したがってアクセスごとにサーバーサイドでランディングページが作られることはありません。

## ⚠️ フルルートキャッシュはせ静的生成ルートのみ対応

静的生成ルートと動的生成ルートの違いが特に複雑なので、詳細は公式ドキュメントを参照してください。それでも大半の人が最初は意味不明だと思うのでここでは噛み砕いて説明します。

Cookie や SearchParams など動的な機能がルート内で使われている場合動的生成ルートになり、それ以外は静的生成ルートになります。

つまりルート内で使用される機能によって暗黙的に（勝手に）切り分けられるので、静的生のつもりが実は動的生成ルート扱いになって毎回レンダリングされていた。ということが容易に発生します。

ちなみにこの動的機能は画面のどこかに存在していたらトリガーになります。Auth.js や Clerk など一般的な認証技術は内部的に Cookie を使います。多くの Web アプリケーションではヘッダーにログインしているユーザーのアイコンを表示していますが、この際に Cookie が使われるので動的生成ルートになります。

たとえばランディングページのような明らかな静的画面であっても、ヘッダーがレイアウトで共有されており、そこにユーザーアバターがあるようなシーンではランディングページも動的生成ルートになります。

これを避けるにはランディングページのレイアウトを動的画面のレイアウトと別にし、かつ認証を使用するコンポーネントがどこにも存在しないことを確認しなければなりません。

:::message
動的生成ルートと動的ルートは別の意味なので混同しないようにしましょう。
動的ルートは `/posts/[slug]/page.tsx` のようにパスが動的に決定するルートです。動的ルートであっても中で動的機能が使われていなければ静的生成ルートとなり、レンダリング結果はフルルートキャッシュされます。
:::

## PPR の登場

以上を踏まえると静的生成ルートは限られたケースでしか発動しません。そのため多くのルートは動的生成ルートとなり、ユーザーのアクセスごとに毎回サーバーサイドで画面がレンダリングされます。

この問題を解決するために PPR が登場しました。PPR は画面内で動的機能を使う箇所を `<Suspense>` で関数を囲むことで部分的に動的レンダリングを行い、それ以外の部分を静的にレンダリングする機能です。

先ほどの例ではヘッダーのユーザーアバターの部分を `<Suspense>` で囲むことで、そこを空にした状態の HTML をフルルートキャッシュしてくれます。

この機能は現在ベータ段階ですが、安定バージョンがリリースされたら必須機能になるでしょう。

# ルーターキャッシュ

ルーターキャッシュはシンプルで、**ブラウザで受け取ったルートの内容を一定時間ブラウザのメモリにキャッシュする機能**です。キャッシュの時間は静的生成ルートの場合 5 分、動的生成ルートの場合 30 秒です。

たとえばマイページにアクセスした時点でマイページのルーターキャッシュが 30 秒間記録されます。トップページや他のページに移動して戻ってきた時にキャッシュが残っていればキャッシュが使われるので、サーバーに画面をリクエストすることなく画面が表示されます。

# 総括

- ORM を使うならデータキャッシュを諦めるか、API を作って fetch 経由でデータキャッシュを作る
- 静的生成ルートに固執せず、PPR が安定するのを待つ
- Getter 系の Server Action は適宜 React Cache で包む
- 現状バグが多すぎるので深追いしない

以上です。
